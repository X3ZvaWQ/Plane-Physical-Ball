<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Ball Ball Ball</title>
    <style>
        html,body{
            overflow: hidden;
            margin: 0;
        }
    </style>
</head>
<body>
    <canvas></canvas>
</body>
<script>
    var friction = 0.25;
    var G = 5.4;
    var canvas = document.querySelector('canvas');
    var ctx = canvas.getContext('2d');
    ctx.clear = function(){
        ctx.clearRect(0,0,canvas.width,canvas.height);
    }
    resizeCanvas();
    
    var ball_list = [];

    for(let i = 0; i < 3; i++){
        ball_list.push(new Ball(i));
    }

    render();
    function render() { 
        ctx.clear();
        gravityEffect();
        paintBalls();
        collisionJudge();
        requestAnimationFrame(render); 
    }

    function gravityEffect(){
        for(ball_a of ball_list){
            for(ball_b of ball_list){
                if(ball_a.gravity_be['from_'+ball_b.id] == undefined && ball_a.id != ball_b.id){
                    var vector = ball_a.vectorTo(ball_b);
                    var distance = normOfVector(vector);
                    var gravity = G * ball_a.quality * ball_b.quality / Math.pow(distance,2);
                    var actual_distance = distance - ball_a.radius - ball_b.radius;
                    var average_radius = (ball_a.radius + ball_b.radius) / 2;
                    if(actual_distance >= average_radius * 2){
                        gravity *= 1;
                    }else if(actual_distance >= average_radius * 1.5){
                        gravity *= 0.85;
                    }else if(actual_distance >= average_radius * 1.0){
                        gravity *= 0.6;
                    }else if(actual_distance >= average_radius * 0.5){
                        gravity *= 0.4;
                    }else if(actual_distance >= average_radius * 0.25){
                        gravity *= 0.1;
                    }else{
                        gravity *= 0;
                    }

                    ball_a.gravity_be['from_'+ball_b.id] = {
                        x : vector.x / distance * gravity,
                        y : vector.y / distance * gravity,
                    }
                    ball_b.gravity_be['from_'+ball_a.id] = {
                        x : - vector.x / distance * gravity,
                        y : - vector.y / distance * gravity,
                    };
                }
            }
        }
        for(ball of ball_list){
            var vector = {
                x : 0,
                y : 0
            }
            for (gravity_vector in ball.gravity_be){
                vector.x += ball.gravity_be[gravity_vector].x;
                vector.y += ball.gravity_be[gravity_vector].y;
            }
            ball.speed.x += vector.x / ball.quality;
            ball.speed.y += vector.y / ball.quality;
            ball.gravity_be = {};
        }
    }

    function preventOverlap(ball_a,ball_b){
        x_after_a = ball_a.position.x + ball_a.speed.x;
        y_after_a = ball_a.position.y + ball_a.speed.y;
        x_after_b = ball_b.position.x + ball_b.speed.x;
        y_after_b = ball_b.position.y + ball_b.speed.y;
        var x = x_after_a - x_after_b;
        var y = y_after_a - y_after_b;
        if(Math.sqrt(x*x + y*y) <= ball_a.radius + ball_b.radius){
            ball_a.position.x += ball_a.speed.x;
            ball_a.position.y += ball_a.speed.y;
            ball_b.position.x += ball_b.speed.x;
            ball_b.position.y += ball_b.speed.y;
            preventOverlap(ball_a,ball_b);
        }
    }

    function collisionJudge(){
        for(ball_a of ball_list){
            for(ball_b of ball_list){
                if(ball_a.distanceTo(ball_b) <= ball_a.radius + ball_b.radius && ball_a.id != ball_b.id && ball_a.collision_ed.indexOf(ball_b.id) == -1 &&  ball_b.collision_ed.indexOf(ball_a.id) == -1){
                    m1 = ball_a.quality;
                    m2 = ball_b.quality;
                    v1 = ball_a.speed.x;
                    v2 = ball_b.speed.x;
                    ball_a.speed.x = ((m1 - m2)*v1 + 2*m2*v2) / (m1 + m2);
                    ball_b.speed.x = ((m2 - m1)*v2 + 2*m1*v1) / (m1 + m2);
                    v1 = ball_a.speed.y;
                    v2 = ball_b.speed.y;
                    ball_a.speed.y = ((m1 - m2)*v1 + 2*m2*v2) / (m1 + m2);
                    ball_b.speed.y = ((m2 - m1)*v2 + 2*m1*v1) / (m1 + m2);
                    preventOverlap(ball_a,ball_b)
                    ball_a.collision_ed.push(ball_b.id);
                    ball_b.collision_ed.push(ball_a.id);
                }
            }
        }
        for(ball of ball_list){
            ball.collision_ed = [];
        }
    }

    function frictionEffect(){

    }

    function paintBalls(){
        for(ball of ball_list){
            ball.paint();
            ball.moveBySpeed();
        }
    }

    function Ball(id){
        this.id = id;
        this.position = {
            x : Math.floor(Math.random()*window.innerWidth + 1),
            y : Math.floor(Math.random()*window.innerHeight + 1),
        };
        this.speed = {
            x : Math.floor(Math.random()*5 - 2.5),
            y : Math.floor(Math.random()*5 - 2.5),
        }
        this.quality = Math.floor(Math.random()*400 + 100);
        this.gravity_be = {};
        this.collision_ed = [];
        this.color = '#fff';
        this.radius = 5 * this.quality / 100;
        this.shadowBlur = 10;
        this.shadowColor = '#000';
        this.paint = function(){
            ctx.shadowBlur = this.shadowBlur;
            ctx.shadowColor = this.shadowColor;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.position.x,this.position.y,this.radius,0,2*Math.PI,false);
            ctx.closePath();
            ctx.fill();
        };
        this.moveBySpeed = function(){
            this.position.x += this.speed.x;
            this.position.y += this.speed.y;
            if(this.position.x - this.radius <= 0 || this.position.x + this.radius >= window.innerWidth){
                this.speed.x *= -1;
            }
            if(this.position.y - this.radius <= 0 || this.position.y + this.radius >= window.innerHeight){
                this.speed.y *= -1;
            }
        };
        this.distanceTo = function(anotherBall){
            x = Math.abs(this.position.x - anotherBall.position.x);
            y = Math.abs(this.position.y - anotherBall.position.y);
            return Math.sqrt(x*x + y*y);
        };
        this.vectorTo = function(anotherBall){
            return {
                x : anotherBall.position.x - this.position.x,
                y : anotherBall.position.y - this.position.y,
            };
        }
    }

    function normOfVector(vector){
        return Math.sqrt(vector.x*vector.x + vector.y*vector.y);
    }

    window.addEventListener('resize',function(e){
        resizeCanvas();
    })
    
    function resizeCanvas(){
        canvas.height = window.innerHeight;
        canvas.width = window.innerWidth;
    }
</script>
</html>